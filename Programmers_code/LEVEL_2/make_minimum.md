## <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12941">최솟값 만들기</a>

### 풀이 (JavaScript)

- 풀이한 날짜 : 2022-12-15

<br/>

```js
function solution(A, B) {
  //   let [newA, newB] = [[], []];

  //   for (let i = A.length - 1; i >= 0; i--) {
  //     for (let j = 0; j < i; j++) {
  //       if (A[j] > A[j+1]) {
  //         [A[j], A[j+1]] = [A[j+1], A[j]]
  //       }
  //     }
  //     newA.unshift(A[i])
  //   }

  //   for (let i = B.length - 1; i >= 0; i--) {
  //     for (let j = 0; j < i; j++) {
  //       if (B[j] < B[j+1]) {
  //         [B[j], B[j+1]] = [B[j+1], B[j]];
  //       }
  //     }
  //     newB.unshift(B[i]);
  //   }
  A.sort((a, b) => a - b);
  B.sort((a, b) => b - a);

  let minSum = 0;
  for (let i = 0; i < A.length; i++) {
    // minSum += newA[i] * newB[i];
    minSum += A[i] * B[i];
  }

  return minSum;
}
```

<br/>

#### 풀이 로직

- (최솟값 \* 최댓값) + (두 번째로 작은 값 \* 두 번째로 큰 값) + ... 식으로 계산하면 누적값이 최소가 된다.

- A, B 두 배열을 각각 오름차순, 내림차순으로 정렬하고 같은 인덱스의 값들을 서로 곱하여 더해나간다.

<br/>

#### 느낀점

- 예전에 한 번 풀었던 문제 같았는데, 그 땐 위의 로직을 바로 생각해냈으나 이번엔 그러지 못했다.

- 처음 문제를 접했을 땐 착각을 하고 배열 길이가 3인 경우만을 고려하여 완전탐색 방법을 생각했다. 그래서 시간이 오래 걸렸고 결국 풀지 못했다.

- 그래서 결국 풀이를 구글링했는데, 그 때 비로소 "아 맞다" 싶었다.

- 다시 풀 땐 버블 정렬 알고리즘을 사용해서 풀었다. 하지만 효율성 검사에서 실패해서, 결국 sort() 메소드를 활용했다.

- (최솟값 \* 최댓값) + (두 번째로 작은 값 \* 두 번째로 큰 값) + ... 식으로 계산하면 누적값이 최소가 되는 이유가 궁금해서 생각해보고 검색도 해보았다. 수식으론 납득이 어렴풋이 갔지만 완전히 이해한 느낌은 아니었다. 아쉽다. 학창 시절에 수학을 지금처럼 좋아했더라면.
