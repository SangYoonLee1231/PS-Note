## <a href="https://www.acmicpc.net/problem/1026">백준 1037번 : 약수 (실버 5)</a>

### 풀이 1

- 풀이한 날짜 : 2022-03-07

<br/>

```python
n = int(input())
lst = list(map(int, input().split()))

if n == 1:
    print(lst[0] * lst[0])
else:
    print(max(lst) * min(lst))
```

#### 풀이 로직

- 진짜 약수는 1과 N이 될 수 없으므로, N은 1과 자신만을 약수로 갖는 소수가 될 수 없다.

- 진짜 약수의 개수가 1개면, 그 값을 제곱하면 N이다.

- 진짜 약수의 개수가 2개 이상이면, 가장 큰 값과 가장 작은 값을 곱하면 N이 된다.

- 이 두 가지 경우가 아닌 예외는 없다.

<br/>

#### 문제 접근 과정 및 느낀점

- 문제를 보자마자 답을 구할 수 있는 핵심 로직이 바로 생각나 빠르게 해결했다.

- 다만 생각한 로직을 벗어나는 예외 케이스가 존재할 가능성이 있다고 생각하여 문제 조건을 꼼꼼히 확인하며 풀이를 점검했다.

- 앞으로도 이렇게 문제를 풀고 잘못된 점은 없는지 신중하게 점검하는 습관을 지니도록 하자.

<br/><br/>

### 풀이 2 (모범 답안 참고)

> <a href="https://hwiyong.tistory.com/353">답안 출처</a>

- 풀이한 날짜 : 2022-03-07

<br/>

```python
n = int(input())
lst = list(map(int, input().split()))

print(max(lst) * min(lst))
```

#### 풀이 로직

- 진짜 약수의 가장 큰 값과 가장 작은 값을 곱하여 출력한다.

<br/>

#### 느낀점

- 음.. 모범 답안을 보니 굳이 약수의 개수에 따라 경우를 나눌 필요가 없었다.

- 앞으로 경우를 나눠 각각 다른 로직을 적용해 문제를 해결하고자 할 때, 동일한 풀이로 해결할 수 있는 여러 경우가 발생하진 않았는지 잘 확인해보자. (안 보이면 할 수 없고)
